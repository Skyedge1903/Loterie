# safemath

Il est important de bien maîtriser les calculs que l'ont fait et éviter les underflows et overflow. Sinon un token ERC20 pourrait perdre toute sa valeur en laissant une vulnérabilité ou autre. Ces

## Addition

Pour l'addition, il faut la somme de deux entiers soit supérieur à au moins un des deux entiers.

```solidity
function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
}
```

## Multiplication

Pour la multiplication, il suffit de s'assurer que multiplier puis diviser nous fais revenir à l'entrée.

```solidity
function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
        return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
}
```
## Division

La division est safe par défaut, la division par défaut causera un `revert`.

```solidity
function div(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a / b;
    return c;
}
```

## Soustraction

La soustraction marche de la même manière que l'addition.
```solidity
function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
}
```
